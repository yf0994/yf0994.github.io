<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Feng yin Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Feng yin Blog">
<meta property="og:url" content="http://fengyinlove.com/index.html">
<meta property="og:site_name" content="Feng yin Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feng yin Blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Feng yin Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="img/bitbug_favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="img/favicon.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">fengyin</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/yf0994/" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android系统/" style="font-size: 10px;">Android系统</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Read the fucking code!</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">fengyin</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="img/favicon.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">fengyin</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/yf0994/" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Android的Init进程-三" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/20/Android的Init进程-三/" class="article-date">
  	<time datetime="2016-01-20T02:20:43.000Z" itemprop="datePublished">2016-01-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/20/Android的Init进程-三/">Android的Init进程(三)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在<strong><em>main()</em></strong>函数的for循环中，会调用<strong><em>restart_processes()</em></strong>函数来启动服务列表中的服务进程。函数restart_processes()的代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart_processes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    process_needs_restart = <span class="number">0</span>;</span><br><span class="line">    service_for_each_flags(SVC_RESTARTING,</span><br><span class="line">                           restart_service_if_needed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中<strong><em>service_for_each_flags()</em></strong>函数会检查service_list列表中的每个服务，凡是带有SVC_RESTARTING标志的，都会使用该服务作为参数调用<strong><em>restart_service_if_needed()</em></strong>函数。<strong><em>restart_serevice_if_needed()</em></strong>函数中会调用<strong><em>service_start()</em></strong>函数来启动服务，我们主要关心的是init如何启动的服务进程，中间的代码就不分析了，直接看<strong><em>service_start()</em></strong>函数的代码。<br>1 重置Service结构中的标志<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">service_start</span><span class="params">(<span class="keyword">struct</span> service *svc, <span class="keyword">const</span> <span class="keyword">char</span> *dynamic_args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* starting a service removes it from the disabled or reset</span><br><span class="line">     * state and immediately takes it out of the restarting</span><br><span class="line">     * state if it was in there</span><br><span class="line">     */</span></span><br><span class="line">    svc-&gt;flags &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));</span><br><span class="line">    svc-&gt;time_started = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* running processes require no additional work -- if</span><br><span class="line">         * they're in the process of exiting, we've ensured</span><br><span class="line">         * that they will immediately restart on exit, unless</span><br><span class="line">         * they are ONESHOT</span><br><span class="line">         */</span></span><br><span class="line">    <span class="keyword">if</span> (svc-&gt;flags &amp; SVC_RUNNING) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>SVC_DISABLED、SVC_RESTARTING、SVC_RESET、SVC_RESTART</em></strong>这4个标志都是和启动进程相关，需要先清除掉。如果服务带有<strong><em>SVC_RUNNING</em></strong>标志，说明服务进程已经运行，这里就不重复启动了。<br>2 如果服务需要有控制台，但是还没有启动控制台就退出<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">needs_console = (svc-&gt;flags &amp; SVC_CONSOLE) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (needs_console &amp;&amp; (!have_console)) &#123;</span><br><span class="line">    ERROR(<span class="string">"service '%s' requires console\n"</span>, svc-&gt;name);</span><br><span class="line">    svc-&gt;flags |= SVC_DISABLED;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中<strong><em>have_console</em></strong>是一个全局变量，在函数<strong><em>console_init_action()</em></strong>中，如果打开设备文件<strong><em>/dev/console</em></strong>成功，它会被置为1。<br>3 检查service的二进制文件是否存在<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (stat(svc-&gt;args[<span class="number">0</span>], &amp;s) != <span class="number">0</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">"cannot find '%s', disabling '%s'\n"</span>, svc-&gt;args[<span class="number">0</span>], svc-&gt;name);</span><br><span class="line">    svc-&gt;flags |= SVC_DISABLED;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>4 检查SVC_ONESHOT参数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ((!(svc-&gt;flags &amp; SVC_ONESHOT)) &amp;&amp; dynamic_args) &#123;</span><br><span class="line">    ERROR(<span class="string">"service '%s' must be one-shot to use dynamic args, disabling\n"</span>,</span><br><span class="line">           svc-&gt;args[<span class="number">0</span>]);</span><br><span class="line">    svc-&gt;flags |= SVC_DISABLED;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>5 设置安全上下文<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (is_selinux_enabled() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (svc-&gt;seclabel) &#123;</span><br><span class="line">        scon = strdup(svc-&gt;seclabel);</span><br><span class="line">        <span class="keyword">if</span> (!scon) &#123;</span><br><span class="line">            ERROR(<span class="string">"Out of memory while starting '%s'\n"</span>, svc-&gt;name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> *mycon = <span class="literal">NULL</span>, *fcon = <span class="literal">NULL</span>;</span><br><span class="line">        INFO(<span class="string">"computing context for service '%s'\n"</span>, svc-&gt;args[<span class="number">0</span>]);</span><br><span class="line">        rc = getcon(&amp;mycon);</span><br><span class="line">        <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"could not get context while starting '%s'\n"</span>, svc-&gt;name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rc = getfilecon(svc-&gt;args[<span class="number">0</span>], &amp;fcon);</span><br><span class="line">        <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"could not get context while starting '%s'\n"</span>, svc-&gt;name);</span><br><span class="line">            freecon(mycon);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rc = security_compute_create(mycon, fcon, string_to_security_class(<span class="string">"process"</span>), &amp;scon);</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">0</span> &amp;&amp; !<span class="built_in">strcmp</span>(scon, mycon)) &#123;</span><br><span class="line">            ERROR(<span class="string">"Warning!  Service %s needs a SELinux domain defined; please fix!\n"</span>, svc-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">        freecon(mycon);</span><br><span class="line">        freecon(fcon);</span><br><span class="line">        <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"could not get context while starting '%s'\n"</span>, svc-&gt;name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>6 fork子进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">pid = fork();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>7 准备环境变量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (properties_inited()) &#123;</span><br><span class="line">        get_property_workspace(&amp;fd, &amp;sz);</span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">"%d,%d"</span>, dup(fd), sz);</span><br><span class="line">        add_environment(<span class="string">"ANDROID_PROPERTY_WORKSPACE"</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (ei = svc-&gt;envvars; ei; ei = ei-&gt;next)</span><br><span class="line">    add_environment(ei-&gt;name, ei-&gt;value);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>在服务的选项中，如果有<strong><em>setenv</em></strong>选项，会将setenv的参数设置为服务进程的环境变量。注意这里把“属性”共享区域的文件句柄fd执行dup后的结果放到了<strong><em>ANDROID_PROPERITY_WORKSPACE</em></strong>环境变量中。这个fd在服务进程不能打开属性共享区的设备文件时使用。<br>8 创建socket<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (si = svc-&gt;sockets; si; si = si-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">int</span> socket_type = (</span><br><span class="line">            !<span class="built_in">strcmp</span>(si-&gt;type, <span class="string">"stream"</span>) ? SOCK_STREAM :</span><br><span class="line">                (!<span class="built_in">strcmp</span>(si-&gt;type, <span class="string">"dgram"</span>) ? SOCK_DGRAM : SOCK_SEQPACKET));</span><br><span class="line">    <span class="keyword">int</span> s = create_socket(si-&gt;name, socket_type,</span><br><span class="line">                          si-&gt;perm, si-&gt;uid, si-&gt;gid, si-&gt;socketcon ?: scon);</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        publish_socket(si-&gt;name, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">freecon(scon);</span><br><span class="line">scon = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>在服务选项中，如果有<strong><em>socket</em></strong>选项，这里会为服务创建参数中定义的socket，这里创建的socket是<strong><em>PF_UNIX</em></strong>类型的，这类socket的创建需要有<strong><em>root</em></strong>权限，因此要在执行<strong><em>exec</em></strong>调用之前创建出来。但是执行exec后服务进程不知道文件描述符也无法使用它。Android的解决办法是将描述符放到了一个环境变量中。环境变量的名字被定义为<strong><em>ANDROID_SOCKET_XXX</em></strong>，XXX是socket选项的名字。这样服务进程就能通过这个特殊名字的环境变量来得到socket的文件描述符了。为了让socket的文件描述符在执行exec后不被关闭，还需要对文件描述符执行<strong><em>fcntl(fd, F_SETFD,0)</em></strong>调用。这些都是在函数<strong><em>publish_socket()</em></strong>中完成的。<br>9 处理标准输入、标准输出、标准错误3个文件描述符<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (needs_console) &#123;</span><br><span class="line">    setsid();</span><br><span class="line">    open_console();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    zap_stdio();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>如果需要使用控制台<strong><em>console</em></strong>。调用<strong><em>open_console()</em></strong>打开设备文件<strong><em>/dev/console</em></strong>，然后把标准输出、标准输入、标准错误重定向到该设备文件；否则调用<strong><em>zap_stdio()</em></strong>，把标准输出、标准输入、标准错误重定向到设备文件<strong><em>/dev/null</em></strong>。<br>10 执行exec<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (!dynamic_args) &#123;</span><br><span class="line">        if (execve(svc-&gt;args[0], (char**) svc-&gt;args, (char**) ENV) &lt; 0) &#123;</span><br><span class="line">            ERROR("cannot execve('%s'): %s\n", svc-&gt;args[0], strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        char *arg_ptrs[INIT_PARSER_MAXARGS+1];</span><br><span class="line">        int arg_idx = svc-&gt;nargs;</span><br><span class="line">        char *tmp = strdup(dynamic_args);</span><br><span class="line">        char *next = tmp;</span><br><span class="line">        char *bword;</span><br><span class="line">            /* Copy the static arguments */</span><br><span class="line">        memcpy(arg_ptrs, svc-&gt;args, (svc-&gt;nargs * sizeof(char *)));</span><br><span class="line">        while((bword = strsep(&amp;next, " "))) &#123;</span><br><span class="line">        arg_ptrs[arg_idx++] = bword;</span><br><span class="line">        if (arg_idx == INIT_PARSER_MAXARGS)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    arg_ptrs[arg_idx] = '\0';</span><br><span class="line">    execve(svc-&gt;args[0], (char**) arg_ptrs, (char**) ENV);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>执行完<strong><em>exec</em></strong>后，init进程的内存映像就被替换成新文件的映像了。上面的代码中调用的是<strong><em>execve()</em></strong>函数，它可以同时设置环境变量。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android的Init进程-二" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/19/Android的Init进程-二/" class="article-date">
  	<time datetime="2016-01-19T10:51:37.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/19/Android的Init进程-二/">Android的Init进程(二)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Init进程的源码位于目录<strong><em>system/core/init</em></strong>下。<strong><em>程序的入口函数main()</em></strong>位于文件init.c中。main()函数比较长，整个Init进程的启动流程都在这个函数中。下面我们把main()函数分成小段，一段段地介绍其功能和作用。<br>进入main()函数后，首先检查启动程序的文件名。如果文件名是<strong><em>uevent</em></strong>，执行守护进程的uevent的主函数<strong><em>uevent_main()</em></strong>，如果文件名是<strong><em>watchdogd</em></strong>，执行看门狗守护进程的主函数<strong><em>watchdogd_main()</em></strong>。若都不是则继续执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>))</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"watchdogd"</span>))</span><br><span class="line">        <span class="keyword">return</span> watchdogd_main(argc, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* clear the umask */</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里可以看出init进程的代码里也包含了另外两个守护进程的代码，因为这几个守护进程的代码重合度高，所以，开发人员干脆把它们都放在一起了。但是在编译时，Android生成了两个指向init文件的符号连接uevent和watchdogd，这样启动时如果执行的是这两个符号连接，main()函数就能判断出到底要启动哪个守护进程。<br>缺省情况下一个进程创建出的文件和文件夹的属性是<strong><em>022</em></strong>，使用<strong><em>umask()</em></strong>函数能设置文件属性的掩码。参数为0意味着进程创建的文件属性是<strong><em>0777</em></strong>。<br>接着创建一些基本的目录，包括/dev、/proc、/sys等；同时把一些文件系统，如tmpfs、devpt、proc、sysfs等mount到相应的目录。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* Get the basic filesystem setup we need put</span><br><span class="line"> * together in the initramdisk on / and then we'll</span><br><span class="line"> * let the rc file figure out the rest.</span><br><span class="line">*/</span></span><br><span class="line">mkdir(<span class="string">"/dev"</span>, <span class="number">0755</span>);</span><br><span class="line">mkdir(<span class="string">"/proc"</span>, <span class="number">0755</span>);</span><br><span class="line">mkdir(<span class="string">"/sys"</span>, <span class="number">0755</span>);</span><br><span class="line"></span><br><span class="line">mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</span><br><span class="line">mkdir(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</span><br><span class="line">mkdir(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>);</span><br><span class="line">mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* indicate that booting is in progress to background fw loaders, etc */</span></span><br><span class="line">close(open(<span class="string">"/dev/.booting"</span>, O_WRONLY | O_CREAT, <span class="number">0000</span>));</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><strong><em>tmpfs</em></strong>是一种基于内存的文件系统，mount后就可以使用。tmpfs文件系统下的文件都存放在内存中，访问速度快，但是关机后所有内容都会丢失，因此tmpfs文件系统比较适合存放一些临时性文件。tmpfs文件系统的大小是动态变化的，刚开始占用空间很小，随着文件的增多会随着变大。Android将tmpfs文件系统mount到/dev目录，/dev目录用来<strong><em>存放系统创建的设备节点</em></strong>，正好符合tmpfs文件系统的特点。<br><strong><em>devpts</em></strong>是虚拟终端文件系统，它通常mount在目录<code>/dev/pts</code>下。<br><strong><em>proc</em></strong>也是一种<strong><em>基于内存的虚拟文件系统</em></strong>，它可以看作是内核内部数据结构的接口，通过它可以获得系统的信息，同时能够运行时修改特定的内核参数。<br><strong><em>sysfd</em></strong>文件系统和proc文件系统类似，它是Linux2.6内核引入的，作用是把系统的设备和总线按层次组织起来，使得它们可以在用户空间存取，用来向用户空间导出内核的数据结构及它们的属性。<br>在<strong><em>/dev</em></strong>    目录下创建一个空文件<strong><em>.booting</em></strong>,表示初始化正在运行。<strong><em>is_booting()</em></strong>函数会依靠空文件<strong><em>.booting</em></strong>来判断是否进程处于初始化中。初始化结束后这个文件将被删除。<br>接下来的代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We must have some place other than / to create the</span><br><span class="line"> * device nodes for kmsg and null, otherwise we won't</span><br><span class="line"> * be able to remount / read-only later on.</span><br><span class="line"> * Now that tmpfs is mounted on /dev, we can actually</span><br><span class="line"> * talk to the outside world.</span><br><span class="line"> */</span></span><br><span class="line">open_devnull_stdio();</span><br><span class="line">klog_init();</span><br><span class="line">property_init();</span><br><span class="line">get_hardware_name(hardware, &amp;revision);</span><br><span class="line">process_kernel_cmdline();</span><br></pre></td></tr></table></figure></p>
<p>调用<strong><em>open_devnull_stdio()</em></strong>函数把标准输入、标准输出和标准错误重定向到空设备文件<strong><em>/dev/<em>null</em></em></strong>，这是创建守护进程常用的手段;调用<strong><em>klog_init()</em></strong>函数创建节点<strong><em>/dev/<strong>kmsg</strong></em></strong>，这样init进程可以使用kernel的log系统来输出log了,这是因为这时Android的log系统还没有启动，所以init只能使用<strong><em>kernel的log系统</em></strong>;调用<strong><em>property_init()</em></strong>函数来初始化Android的属性系统,<strong><em>property_init()</em></strong>函数的主要作用是创建一个共享区域来存储属性值;调用<strong><em>get_hardware_name()</em></strong>函数通过分析<strong><em>/proc/cpuinfo</em></strong>文件，取得系统硬件的名称;调用<strong><em>process_kernel_cmdline()</em></strong>函数解析kernel的启动参数，启动参数通常放在<strong><em>/proc/cmdline</em></strong>中。解析的结果是利用参数中的值来设置几个属性值，包括:<strong><em>ro.serialno</em></strong>、<strong><em>ro.bootmode</em></strong>、<strong><em>ro.baseband</em></strong>、<strong><em>ro.bootloader</em></strong>。<br>接下来初始化<strong><em>SELinux</em></strong>,代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">union</span> selinux_callback cb;</span><br><span class="line">cb.func_log = log_callback;</span><br><span class="line">selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line">cb.func_audit = audit_callback;</span><br><span class="line">selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line"></span><br><span class="line">selinux_initialize();</span><br><span class="line"><span class="comment">/* These directories were necessarily created before initial policy load</span><br><span class="line"> * and therefore need their security context restored to the proper value.</span><br><span class="line"> * This must happen before /dev is populated by ueventd.</span><br><span class="line"> */</span></span><br><span class="line">restorecon(<span class="string">"/dev"</span>);</span><br><span class="line">restorecon(<span class="string">"/dev/socket"</span>);</span><br><span class="line">restorecon(<span class="string">"/dev/__properties__"</span>);</span><br><span class="line">restorecon_recursive(<span class="string">"/sys"</span>);</span><br><span class="line"></span><br><span class="line">is_charger = !<span class="built_in">strcmp</span>(bootmode, <span class="string">"charger"</span>);</span><br><span class="line">property_load_boot_defaults();</span><br><span class="line">init_parse_config_file(<span class="string">"/init.rc"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><strong><em>property_load_boot_defaults()</em></strong>函数将解析设备根目录下的<strong><em>default.prop</em></strong>文件，把这个文件中定义的属性值读出来设置到属性系统中,接着调用<strong><em>init_parse_config_file()</em></strong>函数解析<strong><em>init.rc</em></strong>文件,解析完成后的结果是将init文件中的Server项和Action项分别加入到内部Service列表<strong><em>service_list</em></strong>和Action列表<strong><em>action_list</em></strong>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">action_for_each_trigger(<span class="string">"early-init"</span>, action_add_queue_tail);</span><br><span class="line">queue_builtin_action(wait_for_coldboot_done_action, <span class="string">"wait_for_coldboot_done"</span>);</span><br><span class="line">queue_builtin_action(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line">queue_builtin_action(keychord_init_action, <span class="string">"keychord_init"</span>);</span><br><span class="line">queue_builtin_action(console_init_action, <span class="string">"console_init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* execute all the boot actions to get us started */</span></span><br><span class="line">action_for_each_trigger(<span class="string">"init"</span>, action_add_queue_tail);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span><br><span class="line"> * wasn't ready immediately after wait_for_coldboot_done</span><br><span class="line"> */</span></span><br><span class="line">queue_builtin_action(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line">queue_builtin_action(property_service_init_action, <span class="string">"property_service_init"</span>);</span><br><span class="line">queue_builtin_action(signal_init_action, <span class="string">"signal_init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Don't mount filesystems or start core system services if in charger mode. */</span></span><br><span class="line"><span class="keyword">if</span> (is_charger) &#123;</span><br><span class="line">    action_for_each_trigger(<span class="string">"charger"</span>, action_add_queue_tail);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    action_for_each_trigger(<span class="string">"late-init"</span>, action_add_queue_tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* run all property triggers based on current state of the properties */</span></span><br><span class="line">queue_builtin_action(queue_property_triggers_action, <span class="string">"queue_property_triggers"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>调用<strong><em>action_for_each_trigger()</em></strong>函数用来指定的action加入到执行列表<strong><em>action_queue</em></strong>中，如果系统不在充电模式下，则把<strong><em>late-init”action</em></strong>添加到执行列表中；如果在充电模式，将charger加入到执行列表中。<br><strong><em>queue_builtin_action()</em></strong>函数用来动态生成一个Action并插入到执行列表<strong><em>action_queue</em></strong>中。插入的Action由一个函数指针和一个表示名字的字符串组成。Android在以前的版本中直接调用这些函数来完成某些初始化的工作，但是这些函数可能汇集依赖init.rc里定义的一些命令和服务的执行情况。现在把这些初始化函数也是通过Action的形式插入到执行列表中，这样就能控制它们的执行顺序了。<br>插入的函数有：<br><code>wait_for_coldboot_done_action()函数</code>：等待冷插拔设备初始化完成。<br><code>mix_hwrng_into_linux_rng_action()函数</code>：从硬件RNG的设备文件/dev/hw_random中读取512字节并写到Linux RNG的设备文件/dev/urandom中。<br><code>keychord_init_action()函数</code>：初始化组合键监听模块。<br><code>console_init_action()函数</code>：在屏幕上显示Android字样的Logo。<br><code>property_service_init_action()函数</code>：初始化属性服务，读取系统预置的属性值。<br><code>signal_init_action()函数</code> : 初始化信号处理模块。<br><code>check_startup_action()函数</code> : 检查是否已经完成Init进程的初始化，如果完成则删除.booting文件。<br><code>queue_property_triggers_action()函数</code>: 检查Action列表中通过修改属性来触发的Action，查看相关的属性值是否已经设置，如果已经设置，则将该Action加入到执行列表中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> nr, i, timeout = -<span class="number">1</span>;</span><br><span class="line">    execute_one_command();</span><br><span class="line">    restart_processes();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>main()函数</em></strong>最后会进入到一个无限for循环，每次循环开始都会调用<strong><em>execute_one_command()</em></strong>函数来执行命令列表中的一条命令，同时调用<strong><em>restart_process()</em></strong>函数来启动服务进程。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (!property_set_fd_init &amp;&amp; get_property_set_fd() &gt; 0) &#123;</span><br><span class="line">    ufds[fd_count].fd = get_property_set_fd();</span><br><span class="line">    ufds[fd_count].events = POLLIN;</span><br><span class="line">    ufds[fd_count].revents = 0;</span><br><span class="line">    fd_count++;</span><br><span class="line">    property_set_fd_init = 1;</span><br><span class="line">&#125;</span><br><span class="line">if (!signal_fd_init &amp;&amp; get_signal_fd() &gt; 0) &#123;</span><br><span class="line">    ufds[fd_count].fd = get_signal_fd();</span><br><span class="line">    ufds[fd_count].events = POLLIN;</span><br><span class="line">    ufds[fd_count].revents = 0;</span><br><span class="line">    fd_count++;</span><br><span class="line">    signal_fd_init = 1;</span><br><span class="line">&#125;</span><br><span class="line">if (!keychord_fd_init &amp;&amp; get_keychord_fd() &gt; 0) &#123;</span><br><span class="line">    ufds[fd_count].fd = get_keychord_fd();</span><br><span class="line">    ufds[fd_count].events = POLLIN;</span><br><span class="line">    ufds[fd_count].revents = 0;</span><br><span class="line">    fd_count++;</span><br><span class="line">    keychord_fd_init = 1;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><strong><em>Init</em></strong>进程初始化系统后，会化身为守护进程来处理子进程的死亡信号，修改属性的请求和组合键盘事件。监听事件使用的是<strong>*poll</strong>系统调用，使用poll前需要创建或获得用于监听这些事件的文件描述符，同时初始化<strong><em>poll</em></strong>函数调用需要的数据结构。<br><strong><em>poll()</em></strong>调用可以设置等待超时的时间，参数为－1表示无限等待，参数为0表示要立刻返回，参数为正数表示要等待的时间，下面代码中计算的timeout时间就是用于poll调用的参数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (process_needs_restart) &#123;</span><br><span class="line">    timeout = (process_needs_restart - gettime()) * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!action_queue_empty() || cur_action)</span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> BOOTCHART</span></span><br><span class="line">    <span class="keyword">if</span> (bootchart_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span> || timeout &gt; BOOTCHART_POLLING_MS)</span><br><span class="line">            timeout = BOOTCHART_POLLING_MS;</span><br><span class="line">        <span class="keyword">if</span> (bootchart_step() &lt; <span class="number">0</span> || --bootchart_count == <span class="number">0</span>) &#123;</span><br><span class="line">            bootchart_finish();</span><br><span class="line">            bootchart_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>timeout的初始值为－1。如果还有服务进程需要重启，会把timeout的值设置为下次启动服务的时间。如果命令列表中还有命令，则将timeout的时间设为0。要注意Init中并不是把命令队列中的所有命令一次就执行完毕，而是和poll在交替执行。这主要是考虑到执行所有命令时间太长，如果这期间有事件到来回你耽搁处理，因此，每执行一条列表中的命令就检查一次poll中的事件。<br>如果编译时定义了<strong><em>BOOTACHART宏</em></strong>，也需要定时唤醒进程，因此这里的timeout时间被设置为<strong><em>BOOTACHART_POLLING_MS</em></strong>。Bootchart是一个用可视化的方式对启动过程进行性能分析的工具。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nr = poll(ufds, fd_count, timeout);</span><br><span class="line"><span class="keyword">if</span> (nr &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fd_count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ufds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ufds[i].fd == get_property_set_fd())</span><br><span class="line">            handle_property_set_fd();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ufds[i].fd == get_keychord_fd())</span><br><span class="line">            handle_keychord();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ufds[i].fd == get_signal_fd())</span><br><span class="line">            handle_signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<strong><em>poll()</em></strong>来监听事件的发生，如果监听到修改属性的事件，将会调用处理函数<strong><em>handle_property_set_fd()</em></strong>；如果监听到组合键盘消息，将会调用处理函数<strong><em>handle_keychord()</em></strong>；如果监听到信号，将会调用处理函数<strong><em>handle_signal()</em></strong>。<br><strong><em>poll()函数</em></strong>和<strong><em>select()函数</em></strong>类似，用于监测多个等待事件，但是<strong><em>poll()</em></strong>比<strong><em>select()</em></strong>更加高效，如果没有事件，进程将会挂起，如果监听到任何一个事件发生，<strong><em>poll()</em></strong>将唤醒睡眠的进程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Android的Init进程-一" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/19/Android的Init进程-一/" class="article-date">
  	<time datetime="2016-01-19T10:22:32.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/19/Android的Init进程-一/">Android的Init进程(一)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Init进程是Linux内核启动后创建的第一个用户进程，地位非常重要。Init进程在初始化过程中会启动很多重要的守护进程，因此，了解Init进程的启动过程将有助于我们更好的理解Android系统。Init进程除了完成系统的初始化之外，本身也是一个守护进程，担负着系统部分很重要的职责。<br>Android的启动过程可分为bootloader引导、装载和启动Linux内核、启动Android系统3个大的阶段。其中Android系统启动还可以细分为启动<strong><em>Init进程、启动Zygote进程、启动SystemService、启动SystemServer、启动Home</em></strong>等多个阶段。<br>下面简单介绍设备的启动过程。</p>
<h3 id="281_29_Bootloader_u5F15_u5BFC"><a href="#281_29_Bootloader_u5F15_u5BFC" class="headerlink" title="(1) Bootloader引导"></a>(1) Bootloader引导</h3><p>当我们按下手机的电源键时，最先运行的就是<strong><em>bootloader</em></strong>。Bootloader主要的作用就是初始化基本的硬件设备（如CPU、内存、Flash等）并且通过建立内存空间映射，为装载Linux内核准备好合适的运行环境。一旦Linux内核装载完毕，bootloader将会从内存中清除掉。<br>如果用户在Bootloader运行期间，按下预定义的组合键，可以进入系统的更新模块。Android的下载更新可以选择进入Fastboot模式或者Recovery模式。<br>Fastboot是Android设计的一套通过USB来更新手机分区映像的协议，方便开发人员能快速更新指定的手机分区。<br>Recovery模式是Android特有的升级系统。利用Recovery模式，手机可以进行恢复出场设置或者执行OTA、补丁和固件升级。进入Recovery模式实际上是启动了一个文本模式的Linux。</p>
<h3 id="282_29__u88C5_u8F7D_u548C_u542F_u52A8Linux_u5185_u6838"><a href="#282_29__u88C5_u8F7D_u548C_u542F_u52A8Linux_u5185_u6838" class="headerlink" title="(2) 装载和启动Linux内核"></a>(2) 装载和启动Linux内核</h3><p>Android的<strong><em>boot.img</em></strong>存放的就是Linux内核和一个根文件系统。Bootloader会把<strong><em>boot.img</em></strong>映像装载到内存。然后Linux内核会执行整个系统的初始化，完成后装载根文件系统，最后启动<strong><em>Init进程</em></strong>。</p>
<h3 id="283_29__u542F_u52A8Init_u8FDB_u7A0B"><a href="#283_29__u542F_u52A8Init_u8FDB_u7A0B" class="headerlink" title="(3) 启动Init进程"></a>(3) 启动Init进程</h3><p>Linux内核加载完毕后，会首先启动Init进程，Init进程是系统的第一个进程。在Init进程的启动过程中，会解析Linux的配置脚本<strong><em>init.rc</em></strong>脚本。根据<strong><em>init.rc</em></strong>文件的内容，Init进程会<strong><em>装载Android的文件系统、创建系统目录、初始化系统属性、启动Android系统重要的守护进程</em></strong>，这些进程包括<strong><em>USB守护进程、adb守护进程、vold守护进程、rild守护进程等</em></strong>。最后Init进程也会作为守护进程来执行修改属性请求，重启崩溃的进程等作。</p>
<h3 id="284_29__u542F_u52A8ServiceManager"><a href="#284_29__u542F_u52A8ServiceManager" class="headerlink" title="(4) 启动ServiceManager"></a>(4) 启动ServiceManager</h3><p><strong><em>ServiceManager</em></strong>由Init进程启动。它的主要作用是管理<strong><em>Binder服务</em></strong>，负责Binder服务的注册与查找。</p>
<h3 id="285_29__u542F_u52A8Zygote_u8FDB_u7A0B"><a href="#285_29__u542F_u52A8Zygote_u8FDB_u7A0B" class="headerlink" title="(5) 启动Zygote进程"></a>(5) 启动Zygote进程</h3><p>Init进程初始化结束时，会启动<strong><em>Zygote进程</em></strong>。Zygote进程负责fork出应用进程，是<strong><em>所有应用进程的父进程</em></strong>。Zygote进程初始化时会<strong><em>创建Art虚拟机、预装载系统的资源文件和Java类</em></strong>。所有从Zygote进程fork出的用户进程将继承和共享这些预加载的资源，不用浪费事件重新加载，加快了应用程序的启动过程。启动结束后，Zygote也将变为守护进程，负责响应启动APK应用程序的请求。</p>
<h3 id="286_29__u542F_u52A8SystemServer"><a href="#286_29__u542F_u52A8SystemServer" class="headerlink" title="(6) 启动SystemServer"></a>(6) 启动SystemServer</h3><p><strong><em>SystemServer</em></strong>是Zygote进程fork出的第一个进程，也是整个Android系统的核心进程。在SystemServer中运行着Android系统大部分的Binder服务。SystemServer首先<strong><em>启动本地服务SensorSerrvice</em></strong>；接着启动包括<strong><em>ActivityManagerService、WindowManagerService、PackageManagerService</em></strong>在内的所有Java服务。</p>
<h3 id="287_29__u542F_u52A8MediaServer"><a href="#287_29__u542F_u52A8MediaServer" class="headerlink" title="(7) 启动MediaServer"></a>(7) 启动MediaServer</h3><p><strong><em>MediaServer</em></strong>是由Init进程启动。它包含了一些多媒体相关的本地Binder服务，包括：<strong><em>CameraService、AudioFlingerService、MediaPlayerService和PackageManagerService</em></strong>在内的所有Java服务。</p>
<h3 id="288_29__u542F_u52A8Launcher"><a href="#288_29__u542F_u52A8Launcher" class="headerlink" title="(8) 启动Launcher"></a>(8) 启动Launcher</h3><p>SystemServer加载完所有Java服务后，最后会调用<code>ActivityManagerService的SystemReady()方法</code>。在这个方法的执行中，会发出Intent <code>&quot;android.intent.category.HOME&quot;</code>。凡是响应这个Intent的APK应用都会运行起来，<strong><em>Launcher</em></strong>应用是Android系统默认的桌面应用，一般只有它会响应这个Intent，因此，系统开机后，第一个运行的应用就是Launcher。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 fengyin
    	</div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: undefined,
		mathjax: undefined,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






  </div>
</body>
</html>